
메인 글자 입력기에서는 글자가 명령어와 일치하는지 검사하지 않는다.

글자 읽음-> while 이 글자가 EOF가 아니라면
    isalnum(글자) 글자가 스페이스나 개행문자가 아니라면
        글자 계속 받기
    글자가 스페이스라면
        글자 버퍼 비우고, 구조체에 저장하기
        구조체에 명령어인지 아닌지의 정보를 저장한다.
        구조체에 몇 번째 줄인지의 정보를 저장한다
        구조체 배열에 구조체를 저장하고, 이 배열의 인덱스 값을 1증가시킨다.
    글자가 개행 문자라면
        문자가 스페이스일때와 같은 일을 하지만, 몇 번째 줄인지 나타내는 변수 값에 1을 더한다.

## Instruction_find 함수
검사하려는 스트링의 포인터를 받고, 이미 지정된 명령어와 일치한다면 그 명령어의 번호를 리턴한다.
SIC/XE를 위하여 레지스터도 이걸로 인식시키자 // 교수님께서 SIC/XE는 지원하지 않아도 된다고 하신다.

!! 여기서 명령어 번호는 1부터 센다. (ADD=1,SUB=2....) 따라서 명령어가 검출되면 배열의 인덱스를 바로 돌려주지 않고 1을 더해서 돌려주고, 검출되지 않으면 0을 리턴한다.'
#27번은 NULL 인식. 사용자가 그냥 enter를 누루면 이렇게 된다.


## 프로그램 배열 인식기.
인제 모든 명령어들을 읽어 왔으니 이 명령어되로 임무를 수행할 수 있는  decoder가 필요하다.

루프에 들어가기 전에 먼저 제목을 읽어온다.

if 프로그램 배열의 첬번째 항목이 명령어가 아니라면
    if 다음번에 있는 명령어가 같은 줄에 있고 && 다음 번에 있는 명령어가 START인지 스트링 검사를 한다. //스트링 검사 말고 그냥 Instruction_find 함수에서 키워드들을 모두 읽어 오자.... 아니다, START은 딱 한번만 쓰이는 것이니 매번 검사하는 것보다 처음에 한번만 검사하는 것이 낫다.
        if START 다음에 있는 값이 같은 줄에 있고 && 모두 숫자 값이라면
            인제 프로그램을 실행을 준비한다!
// 제목 값을 라벨 제목과 변수 제목과 비교하여 같은 값이 있으면 오류가 있음을 알려준다.

// 인제 두 번째 줄부터 다시 프로그램 실행을 준비한다.
변수들이 맨 뒤에 선언되어 있고, 모든 변수들이 정의된 후 에 사용되었는지 검사해야하기 때문에 프로그램을 바로 실행 시킬수는 없다. 대신, 변수 배열, 명령어 배열을 만들고, 이를 실행하는 함수를 따로 만든다.
 변수, 명령어 배열을 따로 만드는 것보다 구조체를 또 만드는 게 나을까?


 ### 구조체로 명령어를 실행하는 방법:
     각 구조체는 라벨, 명령어, 값 형식을 지닌다.
     구조체의 인덱스는 명령어의 줄 위치를 나타낸다. //근데 이러면 아무 문자열이 없이 enter 만 했을떄 문제가 생긴다....
     Instruction_find 함수가 완전 공백 ""을 type 26으로 걸러내게 만들었으니 type 26이 검출되면 구조체의 인덱스를 증가시키지 말아야 한다.

## 감지해야할 번역어 지시어
     START 근데 이거는 아마




 type: %d, line: %d

 ,Program[index].type),Program[index].line

struct Word{
    char words[20]; //insruction buffer gets flushed here
    int type; // 0이면 value, 1~25 사이의 값은 명령어, 26은 라벨, 27 제목 값이다.
    int line; //몇 번째 줄에 값이 있는지 나타낸다.
    }

            if (instruction_find(&instruction_buffer[0]) && get_val==0 ){
                valid_instruc=1;
                get_val=1;
                instruc_char_index=0;
            }
            else if(valid_instruc && get_val){
                valid_instruc=0;
                get_val=0;
                val_buffer_index=0;
                printf("that was a value\n");
            }
            else{
                printf("that was not a valid instruction\n");
            }
            instruc_char_index=0;
