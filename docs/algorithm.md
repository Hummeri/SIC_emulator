
메인 글자 입력기에서는 글자가 명령어와 일치하는지 검사하지 않는다.

글자 읽음-> while 이 글자가 EOF가 아니라면
    isalnum(글자) 글자가 스페이스나 개행문자가 아니라면
        글자 계속 받기
    글자가 스페이스라면
        글자 버퍼 비우고, 구조체에 저장하기
        구조체에 명령어인지 아닌지의 정보를 저장한다.
        구조체에 몇 번째 줄인지의 정보를 저장한다
        구조체 배열에 구조체를 저장하고, 이 배열의 인덱스 값을 1증가시킨다.
    글자가 개행 문자라면
        문자가 스페이스일때와 같은 일을 하지만, 몇 번째 줄인지 나타내는 변수 값에 1을 더한다.

## Instruction_find 함수 얘를 keyword find라고 부르는 게 나을것 같다. 나중에 바꾸자
검사하려는 스트링의 포인터를 받고, 이미 지정된 명령어와 일치한다면 그 명령어의 번호를 리턴한다.
SIC/XE를 위하여 레지스터도 이걸로 인식시키자 // 교수님께서 SIC/XE는 지원하지 않아도 된다고 하신다.

!! 여기서 명령어 번호는 1부터 센다. (ADD=1,SUB=2....) 따라서 명령어가 검출되면 배열의 인덱스를 바로 돌려주지 않고 1을 더해서 돌려주고, 검출되지 않으면 0을 리턴한다.'
#26번은 NULL 인식. 사용자가 그냥 enter를 누루면 이렇게 된다.


## 프로그램 배열 인식기.
인제 모든 명령어들을 읽어 왔으니 이 명령어되로 임무를 수행할 수 있는  decoder가 필요하다.

## 빈줄 처리기
    if struct word.type[index] == 26
        index++ 그냥 무시하고 인덱스를 한칸 올린다.
이 코드가 있어야지 사용자가 코드에서 몇칸을 띄고 코드를 작성하여도 이상한 에러가 발생하지 않는다.
나중에 빈 줄 처리기와 주석 처리기도 합께 합쳐서 struct word 포인터를 처리하는 처리기를 만들자.

## 프로그램
루프에 들어가기 전에 먼저 제목을 읽어온다
    if first_word.type is 0
        키워드 아닌 그냥 제목이 맞다!
        나중에 변수 이름이 중복되는 지 검사할때 얘도 비교해야 한다.
        if next_array_content 같은 줄에 있으며, START와 strcmp 명령어를 했을때 참일 때 이 명령어 실행
            if 제목 다음의 값이 같은 줄에 있으며, 숫자 값이다.
                숫자 값을 메모리에 저장한다. 얘를 나중에 프로그램이 어디 메모리 주소에서 작동하는지 계산할 때 쓰인다.

먼저, 선언된 변수들을 모은다.같은 줄에 type 0번인 정의 되지 않은 키워드와 type이 26번 이상인 키워드가 나란히 붙어 있으면 변수를 선언한 것이니 이런 조건을 만족한다면 type이 0번인 변수를 type 26번 이상의 지시어에 따라 알맞은 크기의 변수를 만들자. END == 25

 이 변수들을 만든 다음 변수의 위치를 포인터와 변수의 이름을 모두 가진 구조체에 저장하자.
 명령문을 수행할 때, 변수의 위치에 있는 스트링과 비교해서 선언된 애들 중에 있는지 검사한다.


## 프로그램 assembler
얘가 명령어들을 모아서 실행시킬 수 있는 포맷으로 만든다


이 밑에 내용은 예전 생각. 아마 안 쓸것 같다.
====
if 프로그램 배열의 첬번째 항목이 명령어가 아니라면
    if 다음번에 있는 명령어가 같은 줄에 있고 && 다음 번에 있는 명령어가 START인지 스트링 검사를 한다. //스트링 검사 말고 그냥 Instruction_find 함수에서 키워드들을 모두 읽어 오자.... 아니다, START은 딱 한번만 쓰이는 것이니 매번 검사하는 것보다 처음에 한번만 검사하는 것이 낫다.
        if START 다음에 있는 값이 같은 줄에 있고 && 모두 숫자 값이라면
            인제 프로그램을 실행을 준비한다!
// 제목 값을 라벨 제목과 변수 제목과 비교하여 같은 값이 있으면 오류가 있음을 알려준다.

// 인제 두 번째 줄부터 다시 프로그램 실행을 준비한다.
변수들이 맨 뒤에 선언되어 있고, 모든 변수들이 정의된 후 에 사용되었는지 검사해야하기 때문에 프로그램을 바로 실행 시킬수는 없다. 대신, 변수 배열, 명령어 배열을 만들고, 이를 실행하는 함수를 따로 만든다.
 변수, 명령어 배열을 따로 만드는 것보다 구조체를 또 만드는 게 나을까?


 ### 구조체로 명령어를 실행하는 방법:
     각 구조체는 라벨, 명령어, 값 형식을 지닌다.
     구조체의 인덱스는 명령어의 줄 위치를 나타낸다. //근데 이러면 아무 문자열이 없이 enter 만 했을떄 문제가 생긴다....
     Instruction_find 함수가 완전 공백 ""을 type 26으로 걸러내게 만들었으니 type 26이 검출되면 구조체의 인덱스를 증가시키지 말아야 한다.

## 감지해야할 번역어 지시어
    START 프로그램의 이름과 시작주소를 명시함
	END 프로그램의 끝을 나타내며, 프로그램 이름을 명시함
	BYTE 문자 또는 16진수 상수 생성. 1바이트의 메모리를 확보하고 명시된 상수값을 저장함
	WORD 1-워드의 상수를 생성. 1 바이트의 메모리를 확보하고 명시된 상수값을 저장함
	RESB 데이터 영역(변수)을 위해 명시된 바이트 수만큼 메모리를 확보함
	RESW 데이터 영역(변수)을 위해 명시된 워드 수만큼 메모리를 확보함




 type: %d, line: %d

 ,Program[index].type),Program[index].line

struct Word{
    char words[20]; //insruction buffer gets flushed here
    int type; // 0이면 value, 1~25 사이의 값은 명령어, 26은 라벨, 27 제목 값이다.
    int line; //몇 번째 줄에 값이 있는지 나타낸다.
    }

            if (instruction_find(&instruction_buffer[0]) && get_val==0 ){
                valid_instruc=1;
                get_val=1;
                instruc_char_index=0;
            }
            else if(valid_instruc && get_val){
                valid_instruc=0;
                get_val=0;
                val_buffer_index=0;
                printf("that was a value\n");
            }
            else{
                printf("that was not a valid instruction\n");
            }
            instruc_char_index=0;
