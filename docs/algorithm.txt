
메인 글자 입력기에서는 글자가 명령어와 일치하는지 검사하지 않는다.

글자 읽음-> while 이 글자가 EOF가 아니라면
    isalnum(글자) 글자가 스페이스나 개행문자가 아니라면
        글자 계속 받기
    글자가 스페이스라면
        글자 버퍼 비우고, 구조체에 저장하기
        구조체에 명령어인지 아닌지의 정보를 저장한다.
        구조체에 몇 번째 줄인지의 정보를 저장한다
        구조체 배열에 구조체를 저장하고, 이 배열의 인덱스 값을 1증가시킨다.
    글자가 개행 문자라면
        문자가 스페이스일때와 같은 일을 하지만, 몇 번째 줄인지 나타내는 변수 값에 1을 더한다.

Instruction_find 함수
검사하려는 스트링의 포인터를 받고, 이미 지정된 명령어와 일치한다면 그 명령어의 번호를 리턴한다.
SIC/XE를 위하여 레지스터도 이걸로 인식시키자

!! 여기서 명령어 번호는 1부터 센다. (ADD=1,SUB=2....) 따라서 명령어가 검출되면 배열의 인덱스를 바로 돌려주지 않고 1을 더해서 돌려주고, 검출되지 않으면 0을 리턴한다.'


 type: %d, line: %d

 ,Program[index].type),Program[index].line

struct Word{
    char words[20]; //insruction buffer gets flushed here
    int type; // 0이면 value, 1~25 사이의 값은 명령어, 26은 라벨, 27 제목 값이다.
    int line; //몇 번째 줄에 값이 있는지 나타낸다.
    }

            if (instruction_find(&instruction_buffer[0]) && get_val==0 ){
                valid_instruc=1;
                get_val=1;
                instruc_char_index=0;
            }
            else if(valid_instruc && get_val){
                valid_instruc=0;
                get_val=0;
                val_buffer_index=0;
                printf("that was a value\n");
            }
            else{
                printf("that was not a valid instruction\n");
            }
            instruc_char_index=0;
