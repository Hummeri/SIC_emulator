명렬어들은 3바이트를 사용함. 확장형 명령어를 사용하면 4바이트가 소요됨

# 사칙 연산

## ADD 0x18
명령어 형식: **ADD 변수**
레지스터 A에 저장된 값과 변수에 저장된 값을 서로 더한 다음 다시 레지스터 A에 저장한다.

A += 변수

## SUB 0x1C
명령어 형식: **SUB 변수**
레지스터 A에 저장된 값에서 변수에 저장된 값을 뺀 다음 다시 레지스터 A에 저장한다.

A -=변수

## MUL 0x20
명령어 형식: **MUL 변수**
레지스터 A에 저장된 값과 변수에 저장된 값을 서로 곱한 다음 다시 레지스터 A에 저장한다.

A *=변수

## DIV 0x28
명령어 형식: **AND 변수**
레지스터 A에 저장된 값과 변수에 저장된 값을 서로 나눈 다음 다시 레지스터 A에 저장한다.
나머지 값은 폐기된다.

a /=변수
___

# 논리 연산

## AND 0x40
명령어 형식: **AND 변수**
레지스터 A에 저장된 값과 변수에 저장된 값을 서로 bitwise and 연산을 수행한 다음 다시 레지스터 A에 저장한다.

**예시**
ANDY    START   0000
    LDA     FIVE
	AND    THREE
	STA    RESULT
FIVE	WORD	5
THREE   WORD    3
RESULT  WORD    0
	END    ANDY

레지스터 A에 5를 저장하고 이 값을 3과 AND연산을 수행한다.
5와 3을 각각 이진법으로 표현하면 0101,0011이니 이 <u>각각의 비트에 대하여</u> AND연산을 수행한 값이 최종 결과가 된다.
0101
0011
0001 따라서 변수 RESULT에 저장되는 값은 1이다

## OR 0x44
명령어 형식: **OR 변수**
레지스터 A에 저장된 값과 변수에 저장된 값을 서로 bitwise or 연산을 수행한 다음 다시 레지스터 A에 저장한다.

# 데이터 이동 명령

## LDA 0x00
명령어 형식: **LDA 변수**
레지스터 A에 변수 저장. 한 워드(3바이트, 24비트)만큼을 레지스터 A에 저장한다.
## LDCH 0x50
명령어 형식: **LDCH 변수**
레지스터 A에 변수 저장. 한 글자 만큼의 데이터를(1바이트,8비트) 레지스터 A의 오른쪽 비트에 저장한다.
레지스터 A에 데이터가
0000 0000 0000 0000 0000 0000 (24비트)
이런 식으로 저장되어 있고, LDCH 명령어를 수행하면
0000 0000 0000 0000 <u>0000 0000</u>
밑줄 친 부분에만 데이터가 변경된다.

## LDL 0x08
명령어 형식: **LDL 변수**
레지스터 L에 변수 저장. 한 워드(3바이트, 24비트)만큼을 레지스터 L에 저장한다.

## LDX 0x04
명령어 형식: **LDL 변수**
레지스터 X에 변수 저장. 한 워드(3바이트, 24비트)만큼을 레지스터 X에 저장한다.

## STA 0x0C
명령어 형식: **STA 변수**
레지스터 A의 정보를(3바이트, 24비트 모두) 변수에 저장한다.

## STCH 0x54
명령어 형식: **STA 변수**
STA와 같이 레지스터 A의 데이터를 변수에 저장하지만, 레지스터의 맨 오른쪽 바이트만 변수에 저장한다.

## STL 0x14
명령어 형식: **STL 변수**
레지스터 L의 정보를(3바이트, 24비트 모두) 변수에 저장한다.

## STX 0x10
명령어 형식: **STL 변수**
레지스터 X의 정보를(3바이트, 24비트 모두) 변수에 저장한다.

# 비교 명령

## COMP 0x28
명령어 형식:**COMP 변수**
레지스터 A에 저장된 값과 변수에 저장된 값을 서로 비교하여 CC 레지스터에 결과 값을 저장한다.
레지스터 A에 저장된 값이 변수 값보다 크면 SW레지스터 값에 > 값을 저장한다
레지스터 A에 저장된 값이 변수 값보다 작으면 SW레지스터 값에 < 값을 저장한다
레지스터 A에 저장된 값이 변수 값와 같으면 SW레지스터 값에 = 값을 저장한다

## TIX 2C
명령어 형식:**TIX 변수**
x레지스터의 값에 1을 더하여 x레지스터에 저장하고, x레지스터에 저장되어 있는 정수 값과 메모리에 저장되어 있는 정수값과 메모리에 저장되어 있는 정수 값을 비교하여
그 결과를 SW레지스터에 저장하는 명령이다
이때 저장되는 값은 COMP 몀령어과 같다.

# 분기 명령

## J 0x3C
명령어 형식:**J 레이블**
무조건 분기 명령어. 이 명령어가 실행되면 레이블 위치로 무조건 분기한다.

## JEQ 0x30
명령어 형식:**JEQ 레이블**
SW레지스터 값에 = 값이 저장되어 있으면 레이블 위치로 분기한다

## JGT 0x34
명령어 형식:**JGT 레이블**
SW레지스터 값에 > 값이 저장되어 있으면 레이블 위치로 분기한다

## JLT 0x38
명령어 형식:**JLT 레이블**
SW레지스터 값에 < 값이 저장되어 있으면 레이블 위치로 분기한다

# 서브 루틴 명령

## JSUB 0x48
명령어 형식:**JSUB 레이블**
PC 레지스터의 값을 레지스터 L(Linkage register)에 저장하고 레이블로 분기한다.

## RSUB 0x4C
명령어 형식:**RSUB**
L(Linkage register)에서 저장하였던 주소를 PC레지스터에 저장한다.

# 입출력 명령

## TD 0xE0
명령어 형식:**TD 입력장치**
디바이스를 사용할 수 있을때
sw 레지스터에 LT (<) 를 저장
장치를 사용할 수 없는 상태
 sw 레지스터에 EQ ( == ) 를 저장

## RD 0xD8
명령어 형식:**RD 입력장치**
입력 장치로부터 한 바이트를 읽어와 A 레지스터의 가장 오른쪽 바이트에 저장한다.

## WD
